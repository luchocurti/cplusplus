/****************************** Include Headers *******************************/
#include <iostream>
#include <string>
#include <sstream>

/* Set the namespace (Add visibility of its components) */
using namespace std;

/******************************** Definitions *********************************/
#define IDENTIFIER replacement

/********************************* Constants **********************************/
const char TAB = '\t';

/********************** Functions Prototypes Declaration **********************/
int Addition(int a, int b);
inline int Subtraction(int a, int b);
void DivideByReference(int &a, int b);
int Multiplier(int a, int b = 2);
void DividePointer(int *a, int b);
string ConcatenateByRef(const string &a, const string &b);
void odd(int x);
void even(int x);
long factorial(long a);

/************************************ Main ************************************/
/**
 * @brief Functions allow to structure programs in segments of code to perform
 * individual tasks.
 *
 * @return Returns 0 when execution completes successfully.
 */
int main()
{
    /* Variables */
    int x = 5;
    int y = 3;
    int z;
    string str1 = "Hola";
    string str2 = "Chau";
    long number = 9;

    /* Processing */
    z = Addition(x, y);

    /* Print results */
    cout << endl;
    cout << x << " + " << y << " = " << z << endl;
    cout << x << " - " << y << " = " << Subtraction(x, y) << endl;
    cout << "z = " << z << endl;
    DivideByReference(z, 2);
    cout << "Divide z by 2 (using reference) => " << z << endl;
    DividePointer(&z, 2);
    cout << "Divide z by 2 (using pointer)   => " << z << endl;
    cout << str1 << " + " << str2 << " = " << ConcatenateByRef(str1, str2) << endl;
    cout << "Multipler \'z\' by default value: " << Multiplier(z) << endl;
    cout << "Multipler \'z\' by 10: " << Multiplier(z, 10) << endl;
    odd(1030);
    odd(9);
    cout << number << "! = " << factorial (number) << endl;

    /* Main ended successfully */
    return EXIT_SUCCESS;
}

/**************************** Function Definitions ****************************/
int Addition(int a, int b)
{
    int r;

    r = a + b;

    return r;
}

/*
Preceding a function declaration with the 'inline' specifier informs the
compiler that inline expansion is preferred over the usual function call
mechanism for a specific function. This does not change at all the behavior of a
function, but is merely used to suggest the compiler that the code generated by
the function body shall be inserted at each point the function is called,
instead of being invoked with a regular function call.
*/
inline int Subtraction(int a, int b)
{
    int r;

    r = a - b;

    return r;
}

void DivideByReference(int &a, int b)
{
    a /= b;

    return;
}

/*
In C++, functions can also have optional parameters, for which no arguments are
required in the call, in such a way that, for example, a function with two
parameters may be called with only one. For this, the function shall include a
default value for its last parameter, which is used by the function when called
with fewer arguments.

NOTE that the function prototype is:

                          ---------
    int Multiplier(int a, int b = 2);
                          ---------
*/
int Multiplier(int a, int b)
{
    int r;

    r = a * b;

    return r;
}

void DividePointer(int *a, int b)
{
    (*a) /= b;

    return;
}

/*
To guarantee that the function is not going to modify its reference parameters,
add the 'const' qualifer to the parameters.
By qualifying them as 'const', the function is forbidden to modify the values of
neither 'a' nor 'b', but can actually access their values as references (aliases
of the arguments), without having to make actual copies of the strings.
*/
string ConcatenateByRef(const string &a, const string &b)
{
    return (a + b);
}

void odd(int x)
{
    if ((x % 2) != 0)
    {
        cout << x << " is odd" << endl;
    }
    else
    {
        even(x);
    }

    return;
}

void even(int x)
{
    if ((x % 2) == 0)
    {
        cout << x << " is even" << endl;
    }
    else
    {
        odd(x);
    }

    return;
}

long factorial(long a)
{
    if (a > 1)
    {
        return (a * factorial(a - 1));
    }
    else
    {
        return 1;
    }
}
